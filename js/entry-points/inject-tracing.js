/**
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
goog.provide('audion.entryPoints.injectTracing');

goog.require('audion.autoGenerated.tracingCode');
goog.require('audion.entryPoints.ExtensionTag.FromTracing');
goog.require('audion.entryPoints.ExtensionTag.ToTracing');
goog.require('audion.messaging.MessageType');


/**
 * Handles messages from the background script to this content script. Many of
 * those messages are routed from the dev tools script.
 * @param {*} message
 * @private
 */
audion.entryPoints.handleMessageFromBackground_ = function(message) {
  if (!message) {
    return;
  }

  // Relay any messages from the background page to the window. Label it as from
  // this extension first.
  message = /** @type {!AudionTaggedMessage} */ (message);
  message.tag = audion.entryPoints.ExtensionTag.ToTracing;

  window.postMessage(message, window.location.origin || '*');
};


/**
 * The entry point for actually injecting tracing code into the page. This
 * script executes as a content script. Content scripts for Chrome extensions
 * ... are weird. They can manipulate the page DOM but execute JS in a context
 * different from that of the page. This prevents name collisions, but also
 * means that we cannot directly alter globals in the content script since the
 * page will not heed those changes. We must instead set the injected code as
 * the textContent property of a script tag to execute the code.
 */
audion.entryPoints.injectTracing = function() {
  // Injects the code for tracing web audio calls into the web page via a script
  // tag. Sets up a connection with the background script for routing messages.

  // Execute the instrumentation script by attaching then removing a script tag.
  var scriptTag = document.createElement('script');
  scriptTag.textContent = audion.autoGenerated.tracingCode;
  (document.head || document.documentElement).appendChild(scriptTag);
  scriptTag.remove();

  // Connect with the background page so that it can relay web audio updates to
  // the panel JS.
  var backgroundPageConnection = chrome.runtime.connect({
    'name': 'init_frame'
  });

  backgroundPageConnection.onMessage.addListener(
      audion.entryPoints.handleMessageFromBackground_);

  // Listen to messages from the page. Relay them to the background script.
  window.addEventListener('message', function(event) {
    if (event.source != window) {
      // We are not interested in messages from other windows.
      return;
    }

    var message = /** @type {?AudionTaggedMessage} */ (event.data);
    if (!message ||
         message.tag != audion.entryPoints.ExtensionTag.FromTracing) {
      // This message is not relevant to this extension.
      return;
    }

    // We do not need the tag that identifies this message as from this
    // extension if we are communicating with the background page. Prefer a
    // smaller message (for serialization).
    delete message.tag;
    backgroundPageConnection.postMessage(message);
  });

  // Tell the background page that this content script is ready to receive
  // messages. This kicks off a lot of routing logic in the background script.
  backgroundPageConnection.postMessage(
      /** @type {!AudionListenersReadyMessage} */ ({
    type: audion.messaging.MessageType.LISTENERS_READY
  }));
};


audion.entryPoints.injectTracing();
